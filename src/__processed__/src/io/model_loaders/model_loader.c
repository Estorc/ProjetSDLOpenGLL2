#line 1 "src/io/model_loaders/model_loader.c"
#include "../../raptiquax.h"
#include "../../math/math_util.h"
#include "../model.h"
#include "../shader.h"
#include "obj_loader.h"
#include "../../memory.h"


/**
 * @brief Creates and initializes a Vertex Array Object (VAO) for a given 3D 
 * object, including the necessary vertex buffer data.
 *
 * @param obj {ModelObjectData*} A pointer to the ModelObjectData structure for which the 
 *                      VAO will be created.
 *
 * This function generates a VAO and a Vertex Buffer Object (VBO) for the 
 * specified ModelObjectData. It binds the VBO and uploads vertex data, including 
 * positions, normals, texture coordinates, tangents, and bitangents, to 
 * the GPU. The function also sets up the vertex attribute pointers to 
 * describe the layout of the vertex data in the VBO.
 *
 * Important Notes:
 * - The function assumes that the obj->facesVertex array has been populated 
 *   with valid vertex data prior to calling this function.
 * - The VAO generated by this function is stored in the ModelObjectData structure, 
 *   allowing for easy rendering of the object in subsequent draw calls.
 * - Make sure to bind the VAO when rendering this object to ensure the 
 *   correct vertex data is used.
 *
 * Example Usage:
 * create_obj_vao(&object);
 */

static inline void create_obj_vao(ModelObjectData *obj) {
    VBO VBO;
    glGenBuffers(1, &VBO);

    VAO VAO;
    glGenVertexArrays(1, &VAO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * obj->length * 3, obj->facesVertex, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(3 * sizeof(float)));
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(6 * sizeof(float)));
    glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(8 * sizeof(float)));
    glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(11 * sizeof(float)));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glEnableVertexAttribArray(3);
    glEnableVertexAttribArray(4);

    obj->VAO = VAO;
}


int load_model(const char *path, ModelData ** modelPtr) {
    for (int i = 0; i < memoryCaches.modelsCount; i++) {
        if (!strcmp(memoryCaches.modelCache[i].modelName, path)) {
            #ifdef DEBUG
                printf("Model loaded from cache!\n");
            #endif
            (*modelPtr) = memoryCaches.modelCache[i].model;
            return 0;
        }
    }

    ModelData *model = *modelPtr = malloc(sizeof(ModelData));
    POINTER_CHECK(model);

    model->animationsCount = 0;

    if (path[strlen(path)-1] == 'j') {
        if (load_obj_model(path, model) == -1) return -1;
    } else {
        if (load_fbx_model(path, model) == -1) return -1;
    }

    for (int i = 0; i < model->length; i++) {
        ModelObjectData *obj = &model->objects[i];
        create_obj_vao(obj);
        obj->displayLists = malloc(sizeof(GLuint) * obj->materialsCount);
        POINTER_CHECK(obj->displayLists);
        memset(obj->displayLists, 0, sizeof(GLuint) * obj->materialsCount);
    }
    memoryCaches.modelCache = realloc(memoryCaches.modelCache, sizeof (ModelCache) * (++memoryCaches.modelsCount));
    memoryCaches.modelCache[memoryCaches.modelsCount-1].model = model;
    strcpy(memoryCaches.modelCache[memoryCaches.modelsCount-1].modelName, path);
    return 0;
}