#include "../raptiquax.h"
#include "../math/math_util.h"
#include "../io/model.h"
#include "../render/framebuffer.h"
#include "../storage/node.h"
#include "../window.h"
#include "../render/camera.h"
#include "../render/depth_map.h"
#include "../render/lighting.h"
#include "../io/gltexture_loader.h"
#include "../classes/classes.h"
#include "../memory.h"
#include "../buffer.h"
#include "physics.h"
#include "bodies.h"
#include "collision.h"


void apply_body_collision(Node *shapeA, Node *shapeB, vec3 collisionNormal, vec3 impactPoint, float penetrationDepth) {
    vec3 collisionNormalA;
    (shapeA->parent)::get_collision_normal(collisionNormalA);
    vec3 collisionNormalB;
    (shapeB->parent)::get_collision_normal(collisionNormalB);

    if (collisionNormalA[0] || collisionNormalA[1] || collisionNormalA[2]) {
        glm_vec3_copy(collisionNormalA, collisionNormal);
    }
    if (collisionNormalB[0] || collisionNormalB[1] || collisionNormalB[2]) {
        glm_vec3_negate(collisionNormalB);
        glm_vec3_copy(collisionNormalB, collisionNormal);
    }

    // Mass calculation
    float massA, massB;
    (shapeA->parent)::get_mass(&massA);
    (shapeB->parent)::get_mass(&massB);

    // Calculate relative velocity
    vec3 velocityA, velocityB;
    (shapeA->parent)::get_velocity(velocityA);
    (shapeB->parent)::get_velocity(velocityB);

    // Calculate the relative velocity between the two bodies
    vec3 relativeVelocity;
    glm_vec3_sub(velocityB, velocityA, relativeVelocity);

    // Calculate relative velocity along the normal direction
    float velocityAlongNormal = glm_vec3_dot(relativeVelocity, collisionNormal);

    // Check if objects are separating (no collision response needed)
    if (velocityAlongNormal > 0) {
        //return; // No collision if they're moving apart
    }

    // Calculate the coefficient of restitution (elasticity of the collision)
    float restitution = 0.02; // Adjust based on how "bouncy" the materials are

    // Calculate the impulse scalar (magnitude)
    float invMassA = 1.0 / massA;
    float invMassB = 1.0 / massB;
    float impulseScalar = (1 + restitution) * velocityAlongNormal;
    impulseScalar /= invMassA + invMassB;

    // Calculate the impulse vector
    vec3 impulse;
    glm_vec3_scale(collisionNormal, impulseScalar, impulse);

    // Get the center of mass
    vec3 comA, comB;
    vec3 relativeComA, relativeComB;
    (shapeA->parent)::get_center_of_mass(relativeComA);
    (shapeB->parent)::get_center_of_mass(relativeComB);

    mat4 rotationMatrix4A;
    mat3 rotationMatrixA;
    vec3 radiansRotA;
    glm_vec3_scale(shapeA->parent->globalRot, PI/180.0f, radiansRotA);
    glm_euler(radiansRotA, rotationMatrix4A);
    glm_mat4_pick3(rotationMatrix4A, rotationMatrixA);
    mat4 rotationMatrix4B;
    mat3 rotationMatrixB;
    vec3 radiansRotB;
    glm_vec3_scale(shapeB->parent->globalRot, PI/180.0f, radiansRotB);
    glm_euler(radiansRotB, rotationMatrix4B);
    glm_mat4_pick3(rotationMatrix4B, rotationMatrixB);

    vec3 worldCoMA;
    vec3 worldCoMB;
    glm_mat3_mulv(rotationMatrixA, relativeComA, worldCoMA);  // Rotate CoM
    glm_mat3_mulv(rotationMatrixB, relativeComB, worldCoMB);  // Rotate CoM

    glm_vec3_add(shapeA->parent->globalPos, worldCoMA, comA);
    glm_vec3_add(shapeB->parent->globalPos, worldCoMB, comB);

    // Calculate the point where the impulse is applied relative to the center of mass
    vec3 rA, rB;
    glm_vec3_sub(impactPoint, comA, rA);  // Vector from COM to point of impact for A
    glm_vec3_sub(impactPoint, comB, rB);  // Same for B

    // Torque generated by the impulse (cross product of r and impulse)
    vec3 torqueA, torqueB;
    glm_vec3_cross(rA, impulse, torqueA);  // Torque on A
    glm_vec3_cross(rB, impulse, torqueB);  // Torque on B (if not static)

    // Apply the impulse to both bodies
    vec3 impulseA, impulseB;
    glm_vec3_scale(impulse, invMassA, impulseA); // Affected by massA
    glm_vec3_scale(impulse, invMassB, impulseB); // Affected by massB


    vec3 correction;
    if (penetrationDepth > 0.0f) {
        glm_vec3_scale(collisionNormal, penetrationDepth, correction);
    }
    else
        glm_vec3_zero(correction);

    (shapeA->parent)::apply_impulse(impulseA, torqueA, correction);
    glm_vec3_negate(impulseB);
    glm_vec3_negate(correction);
    (shapeB->parent)::apply_impulse(impulseB, torqueB, correction);
}


void check_collisions(Node *shape) {
    
    for (int i = 0; i < buffers.collisionBuffer.index; i++) {
        Node *shapeA = shape;
        Node *shapeB = buffers.collisionBuffer.collisionsShapes[i];

        bool (*condition)(Node *shapeA, Node *shapeB) = NULL;

        switch (get_collision_code(shapeA, shapeB)) {
            case CTEST_BOX_WITH_BOX:
                condition = check_collision_box_with_box;
            break;
            case CTEST_BOX_WITH_SPHERE:
                condition = check_collision_box_with_sphere;
            break;
            case CTEST_BOX_WITH_PLANE:
                condition = check_collision_box_with_plane;
            break;
            case CTEST_BOX_WITH_CAPSULE:
                condition = check_collision_box_with_capsule;
            break;
            case CTEST_BOX_WITH_MESH:
                condition = check_collision_box_with_mesh;
            break;
            case CTEST_BOX_WITH_RAY:
                condition = check_collision_box_with_ray;
            break;
            case CTEST_SPHERE_WITH_SPHERE:
                condition = check_collision_sphere_with_sphere;
            break;
            case CTEST_SPHERE_WITH_PLANE:
                condition = check_collision_sphere_with_plane;
            break;
            case CTEST_SPHERE_WITH_CAPSULE:
                condition = check_collision_sphere_with_capsule;
            break;
            case CTEST_SPHERE_WITH_MESH:
                condition = check_collision_sphere_with_mesh;
            break;
            case CTEST_SPHERE_WITH_RAY:
                condition = check_collision_sphere_with_ray;
            break;
            case CTEST_PLANE_WITH_PLANE:
                condition = check_collision_plane_with_plane;
            break;
            case CTEST_PLANE_WITH_CAPSULE:
                condition = check_collision_plane_with_capsule;
            break;
            case CTEST_PLANE_WITH_MESH:
                condition = check_collision_plane_with_mesh;
            break;
            case CTEST_PLANE_WITH_RAY:
                condition = check_collision_plane_with_ray;
            break;
            case CTEST_CAPSULE_WITH_CAPSULE:
                condition = check_collision_capsule_with_capsule;
            break;
            case CTEST_CAPSULE_WITH_MESH:
                condition = check_collision_capsule_with_mesh;
            break;
            case CTEST_CAPSULE_WITH_RAY:
                condition = check_collision_capsule_with_ray;
            break;
            case CTEST_MESH_WITH_MESH:
                condition = check_collision_mesh_with_mesh;
            break;
            case CTEST_MESH_WITH_RAY:
                condition = check_collision_mesh_with_ray;
            break;
            case CTEST_RAY_WITH_RAY:
                condition = check_collision_ray_with_ray;
            break;
            default:
                PRINT_ERROR("ERROR: Collision code not found.\n");
                PRINT_ERROR("Collision code: %d\n", get_collision_code(shapeA, shapeB));
            break;
        }

        if (condition(shapeA, shapeB)) {
            // Apply the collision
        }
    }
}


void update_physics(Node *node, vec3 pos, vec3 rot, vec3 scale, float delta, Input *input, Window *window, u8 lightsCount[LIGHTS_COUNT], bool active) {
    vec3 newPos;
    vec3 newRot;
    vec3 newScale;

    glm_vec3_copy(pos, newPos);
    glm_vec3_copy(rot, newRot);
    glm_vec3_copy(scale, newScale);

    if (!(node->flags & NODE_INITIALIZED)) {
        node::emit_ready(delta);
        node->flags |= NODE_INITIALIZED;
    }

    if (node->flags & NODE_ACTIVE && (active || node->flags & NODE_EDITOR_FLAG)) {
        node::emit_update(delta);
        node::update(newPos, newRot, newScale, delta, lightsCount);
    } else {
        active = false;
        node::update_global_position(newPos, newRot, newScale);
    }

    for (int i = 0; i < node->length; i++)
        update_physics(node->children[i], newPos, newRot, newScale, delta, input, window, lightsCount, active);
}