#include "../../raptiquax.h"
#include "../../settings.h"
#include "../../io/osio.h"
#include "../../storage/node.h"
#include "../../io/node_loader.h"
#include "../../gui/frame.h"
#include "../../storage/queue.h"
#include "../../classes/classes.h"

#ifdef DEBUG


static void editor_load_settings(Node *node) {

	Node * settingsRoot = Game.mainTree->root->children[4]->children[0];

	for (int i = 0; i < settingsRoot->length; i++) {
		(settingsRoot->children[i])::free();
	}
	settingsRoot->children = NULL;
	settingsRoot->length = 0;

	void **data = NULL;
	int length = 0;

	node::get_settings_data(&data, &length);
	PRINT_INFO("%d\n", length);
	for (int j = 0, y = 0; j < length;) {
		const char* setting = (const char*) data[j++];
		const char* settingName = data[j++];
		PRINT_INFO("%s\n", setting);
		if (strcmp(setting, "model") == 0) {
			FILE * file = fopen("assets/scenes/editor/settings/model.scene", "r");
			if (file) {
				Node *settingNode = load_node(file, NULL, Game.scripts, NULL);
				Frame *settingFrame = (Frame*) settingNode->object;
				settingFrame->relPos[1] += y;
				(settingNode->children[0]->children[0])::set_text(settingName);
				ModelData **modelData = data[j++];

				MALLOC_ATTRIBUTE(settingNode->children[1], 2);
				settingNode->children[1]->attribute[1].p = modelData;

				settingsRoot::add_child_and_realloc(settingNode);
				fclose(file);
				y += 32;
			}
		}
		if (strcmp(setting, "vec3") == 0) {
			FILE * file = fopen("assets/scenes/editor/settings/vec3.scene", "r");
			if (file) {
				Node *settingNode = load_node(file, NULL, Game.scripts, NULL);
				Frame *settingFrame = (Frame*) settingNode->object;
				settingFrame->relPos[1] += y;
				(settingNode->children[0]->children[0])::set_text(settingName);
				vec3 *vector = data[j++];
				for (int k = 0; k < 3; k++) {
					Node *dimNode = settingNode->children[1+k]->children[1]->children[0];
					MALLOC_ATTRIBUTE(dimNode, 2);
					dimNode->attribute[1].p = (*vector) + k;
				}
				settingsRoot::add_child_and_realloc(settingNode);
				fclose(file);
				y += 32;
			}
		}
		if (strcmp(setting, "rgb") == 0) {
			FILE * file = fopen("assets/scenes/editor/settings/rgb.scene", "r");
			if (file) {
				Node *settingNode = load_node(file, NULL, Game.scripts, NULL);
				Frame *settingFrame = (Frame*) settingNode->object;
				settingFrame->relPos[1] += y;
				(settingNode->children[0]->children[0])::set_text(settingName);
				vec3 *vector = data[j++];
				for (int k = 0; k < 3; k++) {
					Node *dimNode = settingNode->children[1+k]->children[1]->children[0];
					MALLOC_ATTRIBUTE(dimNode, 2);
					dimNode->attribute[1].p = &((*vector)[k]);
				}
				settingsRoot::add_child_and_realloc(settingNode);
				fclose(file);
				y += 32;
			}
		}
		if (strcmp(setting, "float") == 0) {
			FILE * file = fopen("assets/scenes/editor/settings/float.scene", "r");
			if (file) {
				Node *settingNode = load_node(file, NULL, Game.scripts, NULL);
				Frame *settingFrame = (Frame*) settingNode->object;
				settingFrame->relPos[1] += y;
				(settingNode->children[0]->children[0])::set_text(settingName);
				float *value = data[j++];
				Node *dimNode = settingNode->children[1]->children[0];
				MALLOC_ATTRIBUTE(dimNode, 2);
				dimNode->attribute[1].p = value;
				settingsRoot::add_child_and_realloc(settingNode);
				fclose(file);
				y += 32;
			}
		}
		if (strcmp(setting, "node-flags") == 0) {
			FILE * file = fopen("assets/scenes/editor/settings/node-flags.scene", "r");
			if (file) {
				Node *settingNode = load_node(file, NULL, Game.scripts, NULL);
				Frame *settingFrame = (Frame*) settingNode->object;
				settingFrame->relPos[1] += y;
				MALLOC_ATTRIBUTE(settingNode->children[0]->children[0], 2);
				settingNode->children[0]->children[0]->attribute[1].p = node;
				MALLOC_ATTRIBUTE(settingNode->children[1]->children[0], 2);
				settingNode->children[1]->children[0]->attribute[1].p = node;
				j--;
				for (int k = 0; k < 3; k++) {
					Node *scriptNode = settingNode->children[2]->children[1+k]->children[1]->children[0];
					MALLOC_ATTRIBUTE(scriptNode, 2);
					scriptNode->attribute[1].p = data[j++];
				}
				settingsRoot::add_child_and_realloc(settingNode);
				fclose(file);
				y += 96;
			}
		}
	}

	free(data);

}


void load_node_tree(FILE * file, Node *node) {

	Node *loadedScene = load_node(file, 0, Game.scripts, node->parent);
	//(node->children[2])::free();
	loadedScene->flags &= ~NODE_ACTIVE;
	loadedScene->parent = node->parent;
	node->parent->children[2] = loadedScene;
    Game.buffers->collisionBuffer.collisionsShapes = realloc(Game.buffers->collisionBuffer.collisionsShapes, sizeof(Node *) * Game.buffers->collisionBuffer.length);
    Game.buffers->lightingBuffer.lightings = realloc(Game.buffers->lightingBuffer.lightings, sizeof(Node *) * Game.buffers->lightingBuffer.length);

}


void load_menu(Node *node) {

	char path[200];
	if (osio_open_file(path, "../../assets/scenes", "\"Scene File(*.scene)\"") == -1) {
		PRINT_ERROR("Failed to open file\n");
		node->parent->attribute[1].i = 0;
		node->parent->attribute[3].i = 0;
		return;
	}

	FILE * file = fopen(path, "r");
	if (file) {
		load_node_tree(file, node);
		fclose(file);
	}
	node->parent->attribute[1].i = 0;
	node->parent->attribute[3].i = 0;


};

void save_node_tree(FILE * file, Node *node) {

	node_tree_to_file(file, node, Game.mainTree->root);
    bool condition;
	u8 *length;
	Node ***shapes;
	node::is_body(&condition);
    if (condition) {
		node::get_collisions_shapes(&shapes, &length);
		fprintf(file, "\n");
		for (int i = 0; i < *length; i++) {
			save_node_tree(file, (*shapes)[i]);
		}
	}

	char attributes[200];
	attributes[0] = 0;
	if (node->pos[0] || node->pos[1] || node->pos[2]) 
		sprintf(attributes + strlen(attributes), "m%g,%g,%g", node->pos[0], node->pos[1], node->pos[2]);
	if (node->rot[0] || node->rot[1] || node->rot[2]) 
		sprintf(attributes + strlen(attributes), "r%g,%g,%g", node->rot[0], node->rot[1], node->rot[2]);
	if (node->scale[0] != 1 || node->scale[1] != 1 || node->scale[2] != 1) 
		sprintf(attributes + strlen(attributes), "s%g,%g,%g", node->scale[0], node->scale[1], node->scale[2]);
	if (!(node->flags & NODE_ACTIVE))
		sprintf(attributes + strlen(attributes), "a0");
	if (!(node->flags & NODE_VISIBLE))
		sprintf(attributes + strlen(attributes), "v0");
	if (attributes[0]) fprintf(file, "[%s]", attributes);


	char scripts[350];
	scripts[0] = 0;
	if (node->flags & NODE_SCRIPT) {
		fprintf(file, "{");
		for (int j = 0; j < BEHAVIOR_SCRIPT_COUNT; j++) {
			char scriptname[100] = "NULL";
			for (int i = 0; i < __scriptIndex__; i++) {
				if (Game.scripts[i].script == (*node->behavior)[j]) {
					strcpy(scriptname, Game.scripts[i].name);
					break;
				}
					
			}
			sprintf(scripts + strlen(scripts), "%s%c", scriptname, j+1 == BEHAVIOR_SCRIPT_COUNT ? '}' : ',');
		}
	}
	if (strcmp(scripts, "{NULL,NULL,NULL}")) fprintf(file, "%s", scripts);
	if (node->length) fprintf(file, ":%d", node->length);
	fprintf(file, "\n");
    for (int i = 0; i < node->length; i++) {
        save_node_tree(file, node->children[i]);
    }

}

void save_menu(Node *node) {

	char path[200];
	if (osio_save_file(path, "../../assets/scenes", "\"Scene File(*.scene)\"") == -1) {
		node->parent->attribute[1].i = 0;
		node->parent->attribute[3].i = 0;
	}

	if (path[0]) {
		if (!strstr(path, ".scene")) strcat(path, ".scene");
		FILE * file = fopen(path, "w");
		if (file) {
			node->flags |= NODE_ACTIVE;
			save_node_tree(file, node);
			node->flags &= ~NODE_ACTIVE;
			fclose(file);
		}
	}
	node->parent->attribute[1].i = 0;
	node->parent->attribute[3].i = 0;

};

Node * create_add_button(Node * node, int x, int y) {
	FILE * file = fopen("assets/scenes/editor/add.scene", "r");
	if (file) {
		Node *button = load_node(file, NULL, Game.scripts, NULL);
		Frame * frame = (Frame *)button->object;
		frame->relPos[0] = x;
		frame->relPos[1] = y;
		MALLOC_ATTRIBUTE(button->children[0]->children[0], 2);
		button->children[0]->children[0]->attribute[1].node = node;
		fclose(file);
		return button;
	}
	return NULL;
}

Node * create_node_button(Node *node, int x, int y, int level, int index) {
	FILE * file = fopen("assets/scenes/editor/node.scene", "r");
	if (file) {
		Node *button = load_node(file, NULL, Game.scripts, NULL);
		(button->children[6]->children[0])::set_text(classManager.class_names[node->type]);
		Frame * frame = (Frame *)button->object;
		bool condition;
		node::is_cshape(&condition);
		PRINT_INFO("%d\n", index);
		for (int i = 0, j = 0; i < button->length; i++, j++) {
			bool skip = false;
			switch (j) {
				case 0:
				case 1: if (!level) skip = true; break;
				case 2: if (!index || !level || condition) skip = true; break;
				case 3: if ((index + 1 >= node->parent->length) || !level || condition) skip = true; break;
				case 4: if ((index + 1 >= node->parent->length) || !level || condition) skip = true; break;
				case 5: if (level <= 1 || condition) skip = true; break;
			}
			if (skip) {
				button::remove_child_and_free_and_realloc(button->children[i]);
				i--;
			} else {
				Frame *child = (Frame *) button->children[i]->object;
				child->relPos[0] = i*32;
				if (i+1 < button->length) {
					Node *tmpNode = button->children[i]->children[0];
					MALLOC_ATTRIBUTE(tmpNode, 2);
					tmpNode->attribute[1].node = node;
				}
			}
		}
		frame->relPos[0] = x;
		frame->relPos[1] = y;
		fclose(file);
		return button;
	}
	return NULL;
}


void draw_node_tree(Node *node, int level) {

	int window_width, window_height;
	get_resolution(&window_width, &window_height);

	Node * gui_tree = Game.mainTree->root->children[3]->children[0];

	static int y;
	bool condition;
	int x = 4;
	if (level == 0) {
		y = 4;
		for (int i = 0; i < gui_tree->length; i++) {
			(gui_tree->children[i])::free();
		}
		gui_tree->children = NULL;
		gui_tree->length = 0;
	}

    x *= level;
	x += 4;
	int index = (node->parent)::(int)index_of_child(node);
	gui_tree::add_child_and_realloc(create_node_button(node, x, y, level, index));
	y += 32;



	/*draw_rectangle(window->ui_surface, 16, y, 700, 32, 0xff555555);
	if (node != root) if (draw_button(window->ui_surface, x += 32, y, 32, 32, "assets/textures/editor/minus-square.png", 0xffffffff, input)) {
		node::is_cshape(&condition);
		if (condition) remove_shape_and_free_and_realloc(node->parent, node);
		else remove_child_and_free_and_realloc(node->parent, node);
		return;
	}
	if (node != root) if (draw_button(window->ui_surface, x += 32, y, 32, 32, "assets/textures/editor/edit.png", 0xffffffff, input)) {
		root->parent->params[1].i = 1;
		root->parent->params[2].node = node;
	}
	node::is_cshape(&condition);
	if (!condition && index-1 >= 0 && node != root) if (draw_button(window->ui_surface, x += 32, y, 32, 32, "assets/textures/editor/arrow-up-circle.png", 0xffffffff, input)) {
		Node *moved_node = node->parent->children[index-1];
		node->parent->children[index-1] = node->parent->children[index];
		node->parent->children[index] = moved_node;
	}
	node::is_cshape(&condition);
	if (!condition && index+1 < node->parent->length && node != root) if (draw_button(window->ui_surface, x += 32, y, 32, 32, "assets/textures/editor/arrow-down-circle.png", 0xffffffff, input)) {
		Node *moved_node = node->parent->children[index+1];
		node->parent->children[index+1] = node->parent->children[index];
		node->parent->children[index] = moved_node;
	}
	node::is_cshape(&condition);
	if (!condition && index+1 < node->parent->length && level) if (draw_button(window->ui_surface, x += 32, y, 32, 32, "assets/textures/editor/corner-down-right.png", 0xffffffff, input)) {
		Node *parent = node->parent;
		remove_child_and_realloc(parent, node);
		add_child_and_realloc(parent->children[index], node);
	}
	node::is_cshape(&condition);
	if (!condition && level > 1) if (draw_button(window->ui_surface, x += 32, y, 32, 32, "assets/textures/editor/corner-left-up.png", 0xffffffff, input)) {
		remove_child_and_realloc(node->parent, node);
		add_child_and_realloc(node->parent->parent, node);
		return;
	}
	if (node != root) draw_text(window->ui_surface, x + 16 + 32, y+4, classManager.class_names[node->type], font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
	else draw_text(window->ui_surface, x + 16 + 32, y+4, "Root", font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);*/

	u8 *length;
	Node ***shapes;
	node::is_body(&condition);
    if (condition) {
		node::get_collisions_shapes(&shapes, &length);
		for (int i = 0; i < *length; i++) {
        	draw_node_tree((*shapes)[i], level+1);
    	}
	}
    for (int i = 0; i < node->length; i++) {
        draw_node_tree(node->children[i], level+1);
    }



	node::is_cshape(&condition);
	if (!condition) {
		gui_tree::add_child_and_realloc(create_add_button(node, x + 4, y));
		y += 32;
	}



	/*

if (draw_button(window->ui_surface, (level+1)*16 + 16, y, 32, 32, "assets/textures/editor/plus-square.png", 0xffffffff, input)) {
			node::*selectedNodeType::is_cshape(&condition);
			if (condition) {
				node::is_body(&condition);
				if (condition) {
					Node *new_node;
					new_node = malloc(sizeof(Node));
					POINTER_CHECK(new_node);

					malloc_node(new_node, *selectedNodeType, 0, 0, 0, 0);
					add_shape_and_realloc(node, new_node);
				}
			} else {
				Node *new_node;
				new_node = malloc(sizeof(Node));
				POINTER_CHECK(new_node);

				malloc_node(new_node, *selectedNodeType, 0, 0, 0, 0);
				add_child_and_realloc(node, new_node);
				Game.buffers->collisionBuffer.collisionsShapes = realloc(Game.buffers->collisionBuffer.collisionsShapes, sizeof(Node *) * Game.buffers->collisionBuffer.length);
				Game.buffers->lightingBuffer.lightings = realloc(Game.buffers->lightingBuffer.lightings, sizeof(Node *) * Game.buffers->lightingBuffer.length);

			}
		}


	if (!level) {
		if (y < window_height-70) node->parent->params[0].i += ((window_height-70)-y)/20.0;
		if (node->parent->params[0].i > 0) node->parent->params[0].i += (-node->parent->params[0].i)/20.0;
		draw_rectangle(window->ui_surface, 450, window_height-100, 750, 60, 0xff999999);
		draw_text(window->ui_surface, 450, window_height-100+10, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);

		draw_rectangle(window->ui_surface, window_width-64-8, 32-8, 48, 48, 0xff555555);
		if (draw_button(window->ui_surface, window_width-64, 32, 32, 32, "assets/textures/editor/camera.png", 0xffffffff, input)) {
			root->parent->params[1].i = 2;
		}

		draw_rectangle(window->ui_surface, window_width-64-8, 32-8+52, 48, 48, 0xff555555);
		if (draw_button(window->ui_surface, window_width-64, 32+52, 32, 32, "assets/textures/editor/save.png", 0xffffffff, input)) {
			root->parent->params[1].i = 3;
		}

		draw_rectangle(window->ui_surface, window_width-64-8, 32-8+52*2, 48, 48, 0xff555555);
		if (draw_button(window->ui_surface, window_width-64, 32+52*2, 32, 32, "assets/textures/editor/folder.png", 0xffffffff, input)) {
			root->parent->params[1].i = 4;
		}
	}*/


}


void draw_node_tree_wrapper() {
	draw_node_tree(Game.mainTree->root->children[2], 0);
}




#ifdef NOT_COMPILE


void draw_model_input(int *id, int x, int y, Window *window, Node *node, Model **model, Input *input, TTF_Font *font, char * name) {
	char str[150];

    if (draw_button(window->ui_surface, x+800-48, y, 32, 32, "assets/textures/editor/folder.png", 0xffffffff, input)) {
        char path[200];
        if (osio_open_file(path, "assets/models", "\"Object 3d Model File(*.obj)\"") == 0) {
            absolute_path_to_relative(path);
            PRINT_INFO("%s\n", path);
            FILE * file = fopen(path, "r");
            if (file) {
                load_model(path, &(*model)->data);
                fclose(file);
            }
        }
    }
    sprintf(str, "%s: %s", name, "None");
    for (int i = 0; i < Game.memoryCaches->modelsCount; i++) {
        if (Game.memoryCaches->modelCache[i].model == (*model)->data) {
            sprintf(str, "%s: %s", name, Game.memoryCaches->modelCache[i].modelName);
            break;
        }
    }
	draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    (*id)++;
}

void draw_texture_input(int *id, int x, int y, Window *window, Node *node, TextureMap *texture, Input *input, TTF_Font *font, char * name) {
	char str[150];

    if (draw_button(window->ui_surface, x+800-48, y, 32, 32, "assets/textures/editor/folder.png", 0xffffffff, input)) {
        char path[200];
        if (osio_open_file(path, "assets", "\"image/png image/bmp image/jpeg\"") == 0) {
            absolute_path_to_relative(path);
            FILE * file = fopen(path, "r");
            if (file) {
                PRINT_INFO("%s\n", path);
                (*texture) = load_texture_from_path(path, GL_SRGB_ALPHA, true);
                fclose(file);
            }
        }
    }
    sprintf(str, "%s: %s", name, "None");
    for (int i = 0; i < Game.memoryCaches->texturesCount; i++) {
        if (Game.memoryCaches->textureCache[i].textureMap == *texture) {
            sprintf(str, "%s: %s", name, Game.memoryCaches->textureCache[i].textureName);
            break;
        }
    }
	draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    (*id)++;
}

void draw_cubemap_input(int *id, int x, int y, Window *window, Node *node, TextureMap *texture, Input *input, TTF_Font *font, char * name) {
	char str[150];

    if (draw_button(window->ui_surface, x+800-48, y, 32, 32, "assets/textures/editor/folder.png", 0xffffffff, input)) {
        char path[6][200];
        int res = 0;
        for (int i = 0; i < 6; i++) res |= osio_open_file(path[i], "assets", "\"image/png image/bmp image/jpeg\"");
        if (res == 0) {
            for (int i = 0; i < 6; i++) absolute_path_to_relative(path[i]);
            (*texture) = load_cubemap(path);
        }
    }
    (*id)++;
    for (int i = 0; i < Game.memoryCaches->cubeMapCount; i++) {
        if (Game.memoryCaches->cubeMapCache[i].cubeMap == *texture) {
            sprintf(str, "%s: %s", name, Game.memoryCaches->cubeMapCache[i].textureName[0]);
            draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
            sprintf(str, "%s: %s", name, Game.memoryCaches->cubeMapCache[i].textureName[1]);
            draw_text(window->ui_surface, x+10, y+32, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
            sprintf(str, "%s: %s", name, Game.memoryCaches->cubeMapCache[i].textureName[2]);
            draw_text(window->ui_surface, x+10, y+64, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
            sprintf(str, "%s: %s", name, Game.memoryCaches->cubeMapCache[i].textureName[3]);
            draw_text(window->ui_surface, x+10, y+96, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
            sprintf(str, "%s: %s", name, Game.memoryCaches->cubeMapCache[i].textureName[4]);
            draw_text(window->ui_surface, x+10, y+128, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
            sprintf(str, "%s: %s", name, Game.memoryCaches->cubeMapCache[i].textureName[5]);
            draw_text(window->ui_surface, x+10, y+160, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
            return;
        }
    }
    sprintf(str, "%s: None", name);
    draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    sprintf(str, "%s: None", name);
    draw_text(window->ui_surface, x+10, y+32, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    sprintf(str, "%s: None", name);
    draw_text(window->ui_surface, x+10, y+64, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    sprintf(str, "%s: None", name);
    draw_text(window->ui_surface, x+10, y+96, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    sprintf(str, "%s: None", name);
    draw_text(window->ui_surface, x+10, y+128, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    sprintf(str, "%s: None", name);
    draw_text(window->ui_surface, x+10, y+160, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
}


void draw_vec3_input(int *id, int x, int y, Window *window, Node *node, vec3 vector, Input *input, TTF_Font *font, char * name) {
	char str[100];
	sprintf(str, "%s:", name);
	draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
	for (int i = 0; i < 3; i++) {
		sprintf(str, "%c: ", 'X' + i);
		draw_text(window->ui_surface, x+190, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
		if (draw_input_box(window->ui_surface, x+190 + 50, y-1, 140, 28, 0xffd0d0d0, input))
			node->params[3].i = (*id);
		if (node->params[3].i == (*id)) {
			sprintf(str, "%s", input->inputBuffer);
			sscanf(str, "%f", &vector[i]);
		} else sprintf(str, "%.2f", vector[i]);
		draw_text(window->ui_surface, x+190 + 50, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
		x += 200;
        (*id)++;
	}
}

void draw_rgb_input(int *id, int x, int y, Window *window, Node *node, vec3 vector, Input *input, TTF_Font *font, char * name) {
	char str[100];
	sprintf(str, "%s:", name);
	draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
	for (int i = 0; i < 3; i++) {
		sprintf(str, "%c: ", "RGB"[i]);
		draw_text(window->ui_surface, x+190, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
		if (draw_input_box(window->ui_surface, x+190 + 50, y-1, 140, 28, 0xffd0d0d0, input))
			node->params[3].i = (*id);
		if (node->params[3].i == (*id)) {
			sprintf(str, "%s", input->inputBuffer);
			sscanf(str, "%f", &vector[i]);
		} else sprintf(str, "%.2f", vector[i]);
		draw_text(window->ui_surface, x+190 + 50, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
		x += 200;
        (*id)++;
	}
}

void draw_float_input(int *id, int x, int y, Window *window, Node *node, float *flt, Input *input, TTF_Font *font, char * name) {
	char str[100];
	sprintf(str, "%s:", name);
	draw_text(window->ui_surface, x+10, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
	if (draw_input_box(window->ui_surface, x+190, y-1, 590, 28, 0xffd0d0d0, input))
		node->params[3].i = (*id);
	if (node->params[3].i == (*id)) {
		sprintf(str, "%s", input->inputBuffer);
		sscanf(str, "%f", flt);
	} else sprintf(str, "%.2f", *flt);
	draw_text(window->ui_surface, x+190, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
    (*id)++;
}


int update_scene_for_node_editing(Window *window, Node *node, Input *input, TTF_Font *font) {
    Node *selectedNode = node->params[2].node;
    int *scrollY = &node->params[0].i;
    if (*scrollY < 100) *scrollY = 100;
	vec3 gap = {cos(window->time) * 10.0 * *scrollY * 0.01, 0.5 * *scrollY * 0.01, sin(window->time) * 10.0 * *scrollY * 0.01};
	node->children[0]->rot[1] = atan2(gap[0], gap[2])*180.0/PI + 180.0;
	node->children[0]->rot[0] = 0.0;
	node->children[0]->rot[2] = 0.0;
	glm_vec3_copy(selectedNode->globalPos, node->children[0]->pos);
	glm_vec3_add(node->children[0]->pos, gap, node->children[0]->pos);

	s8 collisionShapeID = -1;
	switch (selectedNode->type) {
		case CLASS_TYPE_BOXCSHAPE:
			collisionShapeID = 0;
			break;
		case CLASS_TYPE_PLANECSHAPE:
			collisionShapeID = 1;
			break;
		case CLASS_TYPE_SPHERECSHAPE:
			collisionShapeID = 2;
			if (node->params[3].i == 7) {
				selectedNode->scale[1] = selectedNode->scale[0];
				selectedNode->scale[2] = selectedNode->scale[0];
			}
			if (node->params[3].i == 8) {
				selectedNode->scale[0] = selectedNode->scale[1];
				selectedNode->scale[2] = selectedNode->scale[1];
			}
			if (node->params[3].i == 9) {
				selectedNode->scale[0] = selectedNode->scale[2];
				selectedNode->scale[1] = selectedNode->scale[2];
			}
			break;
		default: break;
	}

	if (collisionShapeID > -1) {
		node->children[1]->children[collisionShapeID]->flags |= NODE_VISIBLE;
		glm_vec3_copy(selectedNode->parent->globalPos, node->children[1]->children[collisionShapeID]->pos);
		glm_vec3_copy(selectedNode->parent->globalRot, node->children[1]->children[collisionShapeID]->rot);
		if (collisionShapeID != 2) glm_vec3_copy(selectedNode->parent->globalScale, node->children[1]->children[collisionShapeID]->scale);
		else glm_vec3_copy(selectedNode->scale, node->children[1]->children[collisionShapeID]->scale);
		update_global_position(selectedNode, node->children[1]->children[collisionShapeID]->pos, node->children[1]->children[collisionShapeID]->rot, node->children[1]->children[collisionShapeID]->scale);
	}
    return collisionShapeID;
}




void save_node_tree(FILE * file, Window *window, Node *node, Node *editor, Input *input, TTF_Font *font) {

	node_tree_to_file(file, node, editor);
	u8 *collisionsLength;
	Node ***collisionsShapes;
	GET_FROM_BODY_NODE(node, length, collisionsLength);
	GET_FROM_BODY_NODE(node, collisionsShapes, collisionsShapes);
    bool condition;
    node::is_body((&condition));
	if (condition) {
		fprintf(file, "\n");
		for (int i = 0; i < *collisionsLength; i++) {
			save_node_tree(file, window, (*collisionsShapes)[i], editor, input, font);
		}
	}
	fprintf(file, "[");
	fprintf(file, "m%g,%g,%g", node->pos[0], node->pos[1], node->pos[2]);
	fprintf(file, "r%g,%g,%g", node->rot[0], node->rot[1], node->rot[2]);
	fprintf(file, "s%g,%g,%g", node->scale[0], node->scale[1], node->scale[2]);
	fprintf(file, "a%d", !!(node->flags & NODE_ACTIVE));
	fprintf(file, "v%d", !!(node->flags & NODE_VISIBLE));
	fprintf(file, "]");

	if (node->flags & NODE_SCRIPT) {
		char scriptname[100] = "None";
		for (int i = 0; i < __scriptIndex__; i++) {
			if (Game.scripts[i].script == (*node->behavior)[BEHAVIOR_SCRIPT_UPDATE]) {
				strcpy(scriptname, Game.scripts[i].name);
				break;
			}
				
		}
		fprintf(file, "{%s}", scriptname);
	}
	if (node->length) fprintf(file, ":%d", node->length);
	fprintf(file, "\n");
    for (int i = 0; i < node->length; i++) {
        save_node_tree(file, window, node->children[i], editor, input, font);
    }

}



int draw_node_params(int x, int y, Window *window, Node *editor, Input *input, TTF_Font *font) {

    int c = 1;
    Node *node = editor->params[2].node;
    switch (node->type) {
        case CLASS_TYPE_NODE:
            {
            //
            }
            break;

        case CLASS_TYPE_CAMERA:
            {
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            if (draw_button(window->ui_surface, x+400-16, y, 32, 32, editor->params[5].node == node ? "assets/textures/editor/camera.png" : "assets/textures/editor/camera-off.png", 0xffffffff, input)) {
                if (editor->params[5].node == node) editor->params[5].node = 0;
                else editor->params[5].node = node;
            }
            y += 32;
            }
            break;

        case CLASS_TYPE_KINEMATICBODY:
            {
            KinematicBody *kinematicBody = (KinematicBody*) node->object;

            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_vec3_input(&c, x, y, window, editor, kinematicBody->velocity, input, font, "Velocity");
            y += 32;
            }
            break;

        case CLASS_TYPE_RIGIDBODY:
            {
            RigidBody *rigidBody = (RigidBody*) node->object;

            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_vec3_input(&c, x, y, window, editor, rigidBody->velocity, input, font, "Velocity");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_vec3_input(&c, x, y, window, editor, rigidBody->angularVelocity, input, font, "Ang. Vel.");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_vec3_input(&c, x, y, window, editor, rigidBody->gravity, input, font, "Gravity");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &rigidBody->mass, input, font, "Mass");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &rigidBody->friction, input, font, "Friction");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_vec3_input(&c, x, y, window, editor, rigidBody->centerOfMass, input, font, "CoM");
            y += 32;
            break;
            }
        case CLASS_TYPE_STATICBODY:
            {
            //
            }
            break;

        case CLASS_TYPE_MESH:
            {
            //
            }
            break;

        case CLASS_TYPE_MODEL:
            {
            Model **model = (Model**) &node->object;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_model_input(&c, x, y, window, editor, model, input, font, "Model");
            y += 32;
            }
            break;

        case CLASS_TYPE_TEXTUREDMESH:
            {
            TextureMap *texture = &((TexturedMesh*) node->object)->texture;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_texture_input(&c, x, y, window, editor, texture, input, font, "Texture");
            y += 32;
            }
            break;

        case CLASS_TYPE_SKYBOX:
            {
            TextureMap *texture = &((TexturedMesh*) node->object)->texture;
            draw_rectangle(window->ui_surface, x, y, 800, 192, 0xff555555);
            draw_cubemap_input(&c, x, y, window, editor, texture, input, font, "Texture");
            y += 192;
            }
            break;

        case CLASS_TYPE_FRAMEBUFFER:
            {
            //
            }
            break;

        case CLASS_TYPE_POINTLIGHT:
            {
            PointLight *pointLight = (PointLight*) node->object;

            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, pointLight->ambient, input, font, "Ambient");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, pointLight->diffuse, input, font, "Diffuse");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, pointLight->specular, input, font, "Specular");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &pointLight->constant, input, font, "Constant");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &pointLight->linear, input, font, "Linear");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &pointLight->quadratic, input, font, "Quadratic");
            y += 32;
            break;
            }

        case CLASS_TYPE_DIRECTIONALLIGHT:
            {
            DirectionalLight *directionalLight = (DirectionalLight*) node->object;

            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, directionalLight->ambient, input, font, "Ambient");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, directionalLight->diffuse, input, font, "Diffuse");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, directionalLight->specular, input, font, "Specular");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &directionalLight->constant, input, font, "Constant");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &directionalLight->linear, input, font, "Linear");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &directionalLight->quadratic, input, font, "Quadratic");
            y += 32;
            break;
            }
        case CLASS_TYPE_SPOTLIGHT:
            {
            SpotLight *spotLight = (SpotLight*) node->object;

            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, spotLight->ambient, input, font, "Ambient");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, spotLight->diffuse, input, font, "Diffuse");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_rgb_input(&c, x, y, window, editor, spotLight->specular, input, font, "Specular");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &spotLight->constant, input, font, "Constant");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &spotLight->linear, input, font, "Linear");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &spotLight->quadratic, input, font, "Quadratic");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &spotLight->cutOff, input, font, "Cut Off");
            y += 32;
            draw_rectangle(window->ui_surface, x, y, 800, 32, 0xff555555);
            draw_float_input(&c, x, y, window, editor, &spotLight->outerCutOff, input, font, "Outer Cut Off");
            y += 32;
            break;
            }
    }

    return y;
}


void draw_node_settings(Window *window, Node *node, Input *input, TTF_Font *font) {

	int window_width, window_height;
	get_resolution(&window_width, &window_height);

	update_scene_for_node_editing(window, node, input, font);

	draw_rectangle(window->ui_surface, window_width-64-8, 32-8, 48, 48, 0xff555555);
	if (draw_button(window->ui_surface, window_width-64, 32, 32, 32, "assets/textures/editor/corner-left-up.png", 0xffffffff, input)) {
		node->params[1].i = 1;
		node->params[3].i = 0;
	}
	
	int y = node->params[0].i;
	int x = window_width/2;

	draw_rectangle(window->ui_surface, x-400, y-20, 800, 20, 0xff555555);
	y = draw_node_params(x-400, y, window, node, input, font);
	draw_rectangle(window->ui_surface, x-400, y, 800, 20, 0xff555555);
	y += 20;

	if (input->pressed_keys & KEY_VALIDATE)
		node->params[3].i = 0;

	if (y < window_height-70) node->params[0].i += ((window_height-70)-y)/20.0;
	if (node->params[0].i > 0) node->params[0].i += (-node->params[0].i)/20.0;

}



void draw_node_editing(Window *window, Node *node, Input *input, TTF_Font *font) {

	int window_width, window_height;
	get_resolution(&window_width, &window_height);

	Node *selectedNode = node->params[2].node;
	int collisionShapeID = update_scene_for_node_editing(window, node, input, font);

	char scriptname[100] = "None";
	for (int i = 0; i < __scriptIndex__; i++) {
		if (Game.scripts[i].script == (*selectedNode->behavior)[BEHAVIOR_SCRIPT_UPDATE]) {
			strcpy(scriptname, Game.scripts[i].name);
			break;
		}
			
	}

	draw_rectangle(window->ui_surface, window_width-64-8, 32-8, 48, 48, 0xff555555);
	if (draw_button(window->ui_surface, window_width-64, 32, 32, 32, "assets/textures/editor/corner-left-up.png", 0xffffffff, input)) {
		if (collisionShapeID > -1) node->children[1]->children[collisionShapeID]->flags &= ~NODE_VISIBLE;
		node->params[1].i = 0;
		glm_vec3_zero(node->children[0]->rot);
		glm_vec3_zero(node->children[0]->pos);
		node->params[3].i = 0;
	}

	bool condition;
	selectedNode::is_cshape(&condition);
	if (!condition) {
		draw_rectangle(window->ui_surface, window_width-64-8, 32-8+52, 48, 48, 0xff555555);
		if (draw_button(window->ui_surface, window_width-64, 32+52, 32, 32, "assets/textures/editor/settings.png", 0xffffffff, input)) {
			node->params[3].i = 0;
			node->params[1].i = 5;
		}
	}
	
	char str[100];
	int y = window_height/2+100;
	int x = window_width/2;
	int c = 1;

	draw_rectangle(window->ui_surface, x-400, y-20, 800, 200, 0xff555555);
	draw_vec3_input(&c, x-400, y, window, node, selectedNode->pos, input, font, "Position");
	y += 32;
	draw_vec3_input(&c, x-400, y, window, node, selectedNode->rot, input, font, "Rotation");
	y += 32;
	draw_vec3_input(&c, x-400, y, window, node, selectedNode->scale, input, font, "Scale");
	y += 48;

	if (draw_button(window->ui_surface, x-390, y, 32, 32, selectedNode->flags & NODE_VISIBLE ? "assets/textures/editor/eye.png" : "assets/textures/editor/eye-off.png", 0xffffffff, input)) {
		if (selectedNode->flags & NODE_VISIBLE)
			selectedNode->flags &= ~NODE_VISIBLE;
		else
			selectedNode->flags |= NODE_VISIBLE;
	}

	x += 48;

	if (draw_button(window->ui_surface, x-390, y, 32, 32, selectedNode->flags & NODE_ACTIVE ? "assets/textures/editor/active.png" : "assets/textures/editor/unactive.png", 0xffffffff, input)) {
		if (selectedNode->flags & NODE_ACTIVE)
			selectedNode->flags &= ~NODE_ACTIVE;
		else
			selectedNode->flags |= NODE_ACTIVE;
	}

	x += 96;

	draw_text(window->ui_surface, x-390, y, "Script:", font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);
	if (draw_input_box(window->ui_surface, x-230+  0, y-1, 300, 28, 0xffd0d0d0, input))
		node->params[3].i = 10;
	if (node->params[3].i == 10) {
		sprintf(str, "%s", input->inputBuffer);
		sscanf(str, "%s", scriptname);
	} else sprintf(str, "%s", scriptname);
	draw_text(window->ui_surface, x-230, y, str, font, (SDL_Color) {255, 255, 255, 255}, "lt", -1);

	if (input->pressed_keys & KEY_VALIDATE) {
		if (node->params[3].i == 10) {
			if (!strcmp(scriptname, "None")) {
				selectedNode->flags &= ~NODE_SCRIPT;
				(*selectedNode->behavior)[BEHAVIOR_SCRIPT_UPDATE] = NULL;
			}
			else for (int i = 0; i < __scriptIndex__; i++) {
				if (!strcmp(Game.scripts[i].name, scriptname)) {
					selectedNode->flags |= NODE_SCRIPT;
					(*selectedNode->behavior)[BEHAVIOR_SCRIPT_UPDATE] = Game.scripts[i].script;
				}
					
			}
		}
		node->params[3].i = 0;
	}

}

#endif
#endif



NEW_SCRIPT(scene_editor_init)
#ifdef DEBUG
	SET_ATTRIBUTES_COUNT(6);
	int *selectedNodeType = &this->attribute[4].i;

	Game.window->fadeColor[3] = 0.0;
	draw_node_tree(this->children[2], 0);

	char str[150];
	sprintf(str, " < %s > ", classManager.class_names[*selectedNodeType]);
	(this->children[3]->children[1]->children[0])::set_text(str);
#endif
END_SCRIPT(scene_editor_init)




NEW_SCRIPT(scene_editor)
#ifdef DEBUG
	GET_READY_PARAMETERS();

	int window_width, window_height;
	get_resolution(&window_width, &window_height);

	int *scrollY = &this->attribute[0].i;
	//int *menu = &this->attribute[1].i;
	//Node *selectedNode = node->params[2].node;
	//int *selectedInputBox = &node->params[3].i;
	int *selectedNodeType = &this->attribute[4].i;
	//Node *activeCamera = node->params[5].node;



	if (Game.input->mouse.active_button) (*scrollY) -= Game.input->mouse.lastY - Game.input->mouse.y;
	(*scrollY) += Game.input->mouse.scroll_y*50.0f;

	int lastSelectedNodeType = *selectedNodeType;
	if (Game.input->pressed_keys & KEY_LEFT) (*selectedNodeType)--;
	if (Game.input->pressed_keys & KEY_RIGHT) (*selectedNodeType)++;
	if (*selectedNodeType < 0) *selectedNodeType = CLASS_TYPE_COUNT-1;
	if (*selectedNodeType >= CLASS_TYPE_COUNT) *selectedNodeType = 0;
	if (lastSelectedNodeType != *selectedNodeType) {
		char str[150];
		sprintf(str, " < %s > ", classManager.class_names[*selectedNodeType]);
		(this->children[3]->children[1]->children[0])::set_text(str);
	}
#endif

END_SCRIPT(scene_editor)



NEW_SCRIPT(scene_editor_btn_load)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(1);
	bool *active = &this->attribute[0].b;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		load_menu(Game.mainTree->root->children[2]);
		draw_node_tree(Game.mainTree->root->children[2], 0);
		*button->checked = false;
	}
#endif
END_SCRIPT(scene_editor_btn_load)

NEW_SCRIPT(scene_editor_btn_save)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(1);
	bool *active = &this->attribute[0].b;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		save_menu(Game.mainTree->root->children[2]);
		*button->checked = false;
	}
#endif
END_SCRIPT(scene_editor_btn_save)

NEW_SCRIPT(scene_editor_btn_camera)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(1);
	bool *active = &this->attribute[0].b;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		SDL_SetRelativeMouseMode(SDL_TRUE);
		Game.mainTree->root->children[0]->attribute[0].i = 1;
		Game.mainTree->root->children[0]->attribute[1].i = 1;
		Game.mainTree->root->children[3]->flags &= ~NODE_VISIBLE;
		Game.mainTree->root->children[3]->flags &= ~NODE_ACTIVE;
		*button->checked = false;
	}
#endif
END_SCRIPT(scene_editor_btn_camera)






NEW_SCRIPT(scene_editor_btn_add_node)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(2);
	bool *active = &this->attribute[0].b;
	Node *node = this->attribute[1].node;
	int *selectedNodeType = &Game.mainTree->root->attribute[4].i;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		bool condition;
		call_method_0(METHOD_TYPE(*selectedNodeType, is_cshape, NULL, &condition));
		if (condition) {
			node::is_body(&condition);
			if (condition) {
				Node *new_node;
				new_node = malloc(sizeof(Node));
				POINTER_CHECK(new_node);

				malloc_node(new_node, *selectedNodeType, 0, 0, 0, 0);
				node::add_shape_and_realloc(new_node);
				queue_push(Game.callQueue, draw_node_tree_wrapper);
			}
		} else {
			Node *new_node;
			new_node = malloc(sizeof(Node));
			POINTER_CHECK(new_node);

			malloc_node(new_node, *selectedNodeType, 0, 0, 0, 0);
			node::add_child_and_realloc(new_node);
			Game.buffers->collisionBuffer.collisionsShapes = realloc(Game.buffers->collisionBuffer.collisionsShapes, sizeof(Node *) * Game.buffers->collisionBuffer.length);
			Game.buffers->lightingBuffer.lightings = realloc(Game.buffers->lightingBuffer.lightings, sizeof(Node *) * Game.buffers->lightingBuffer.length);
			queue_push(Game.callQueue, draw_node_tree_wrapper);
		}
		*active = false;
	}
#endif
END_SCRIPT(scene_editor_btn_add_node)


NEW_SCRIPT(scene_editor_btn_remove_node)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(2);
	bool *active = &this->attribute[0].b;
	Node *node = this->attribute[1].node;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		bool condition;
		node::is_cshape(&condition);
		if (condition) (node->parent)::remove_shape_and_free_and_realloc(node);
		else (node->parent)::remove_child_and_free_and_realloc(node);
		*active = false;
		queue_push(Game.callQueue, draw_node_tree_wrapper);
	}
#endif
END_SCRIPT(scene_editor_btn_remove_node)


NEW_SCRIPT(scene_editor_btn_edit_node)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(2);
	bool *active = &this->attribute[0].b;
	Node *node = this->attribute[1].node;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		Game.mainTree->root->children[3]->flags &= ~NODE_VISIBLE;
		Game.mainTree->root->children[3]->flags &= ~NODE_ACTIVE;
		Game.mainTree->root->children[4]->flags |= NODE_VISIBLE;
		Game.mainTree->root->children[4]->flags |= NODE_ACTIVE;
		Game.window->flags |= WINDOW_RESIZED;
		
		editor_load_settings(node);
		*button->checked = false;
	}
#endif
END_SCRIPT(scene_editor_btn_edit_node)

NEW_SCRIPT(scene_editor_edit_mode)
#ifdef DEBUG
	if (Game.input->released_keys & KEY_MENU) {
		Game.mainTree->root->children[3]->flags |= NODE_VISIBLE;
		Game.mainTree->root->children[3]->flags |= NODE_ACTIVE;
		Game.mainTree->root->children[4]->flags &= ~NODE_VISIBLE;
		Game.mainTree->root->children[4]->flags &= ~NODE_ACTIVE;
		(Game.mainTree->root->children[3]->children[0])::refresh();
		Game.window->flags |= WINDOW_RESIZED;
	}
#endif
END_SCRIPT(scene_editor_edit_mode)


NEW_SCRIPT(scene_editor_btn_show_collisions)
#ifdef DEBUG
	GET_READY_PARAMETERS();
	SET_ATTRIBUTES_COUNT(1);
	bool *active = &this->attribute[0].b;
	Frame *frame = (Frame*) this->object;
	Button *button = (Button*) frame->button;

	if (!button->checked) button->checked = active;
	if ((*button->checked)) {
		Game.settings->show_collision_boxes = !Game.settings->show_collision_boxes;
		*button->checked = false;
	}
#endif
END_SCRIPT(scene_editor_btn_show_collisions)